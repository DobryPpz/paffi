#!/usr/bin/env python3
'''
paffi
Copyright (C) 2024 Aleksander Modzelewski

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

This is a program where you input a text file consisting of lines of characters.
. -> this character means the starting points(default).
x -> this character means targets(default).
[:space:] -> whitespace means empty cells we can travel to.
Any other character means obstacle.
The program will read in such file and draw the shortest paths from starting
points to targets. The shortest paths will be drawn with @ character(default).
You can specify the following options:
-s <c>  ->  the starting point character will be <c>
-t <c>  ->  the target character will be <c>
-p <c>  ->  the paths will be drawn with <c> character
-n <c>  ->  the neighbourhood: 4 for Von Neumann(default), 8 for Moore
'''

import sys
import argparse
from collections import deque, namedtuple

STARTING_CHAR = '.'
TARGET_CHAR = 'x'
PATH_CHAR = '@'
EXTENDED_NEIGHBOURHOOD = False


def validate_starting_char(char):
    if len(char) != 1:
        print(f'{char}:  This can\'t be a starting character', file=sys.stderr)
        exit(-1)
    global STARTING_CHAR
    STARTING_CHAR = char


def validate_target_char(char):
    if len(char) != 1:
        print(f'{char}:  This can\'t be a target character', file=sys.stderr)
        exit(-1)
    global TARGET_CHAR
    TARGET_CHAR = char


def validate_path_char(char):
    if len(char) != 1:
        print(f'{char}:  This can\'t be a path character', file=sys.stderr)
        exit(-1)
    global PATH_CHAR
    PATH_CHAR = char


def validate_neighbourhood(n):
    if n != '4' and n != '8':
        print(f'{n}:  No such neighbourhood available', file=sys.stderr)
        exit(-1)
    global EXTENDED_NEIGHBOURHOOD
    if n == '4':
        EXTENDED_NEIGHBOURHOOD = False
    elif n == '8':
        EXTENDED_NEIGHBOURHOOD = True


Point = namedtuple('point', ['row', 'col'])


def go_up(point: Point):
    return Point(point.row-1, point.col)


def go_up_right(point: Point):
    return Point(point.row-1, point.col+1)


def go_right(point: Point):
    return Point(point.row, point.col+1)


def go_down_right(point: Point):
    return Point(point.row+1, point.col+1)


def go_down(point: Point):
    return Point(point.row+1, point.col)


def go_down_left(point: Point):
    return Point(point.row+1, point.col-1)


def go_left(point: Point):
    return Point(point.row, point.col-1)


def go_up_left(point: Point):
    return Point(point.row-1, point.col-1)


class World:
    def __init__(self, extended_neighbourhood) -> None:
        self.field = []
        self.starting_points = []
        self.paths = []
        self.prevs = {}
        self.can_to = set([STARTING_CHAR, TARGET_CHAR, ' '])
        self.extended_neighbourhood = extended_neighbourhood
        self.possible_directions = [go_up, go_right,
                                    go_down, go_left] + ([
                                        go_up_right,
                                        go_up_left,
                                        go_down_right,
                                        go_down_left] if self.extended_neighbourhood else [])

    def add_row(self, row: str):
        row = row.strip('\n')
        if row != '':
            self.field.append(row)
        else:
            self.field.append(' ')

    def is_point_valid(self, point: Point):
        row = point.row
        col = point.col
        if row < 0 or row >= len(self.field):
            return False
        if col < 0 or col >= len(self.field[row]):
            return False
        if self.field[row][col] not in self.can_to:
            return False
        return True

    def do_padding(self):
        longest_line_len = 1
        for row in self.field:
            line_len = len(row)
            if line_len > longest_line_len:
                longest_line_len = line_len
        for i in range(len(self.field)):
            diff_len = longest_line_len - len(self.field[i])
            if diff_len > 0:
                self.field[i] += ' '*diff_len

    def change_tabs_to_spaces(self):
        num_rows = len(self.field)
        for r in range(num_rows):
            if '\t' in self.field[r]:
                self.field[r] = self.field[r].replace('\t', '    ')

    def can_go_from(self, point: Point):
        candidate_destinations = list(
            map(lambda dir: dir(point), self.possible_directions))
        possible_destinations = [
            d for d in candidate_destinations if self.is_point_valid(d)]
        return possible_destinations

    def find_starts(self):
        num_rows = len(self.field)
        for i in range(num_rows):
            row_len = len(self.field[i])
            for j in range(row_len):
                if self.field[i][j] == STARTING_CHAR:
                    self.starting_points.append(Point(i, j))

    def add_path(self, src: Point, dst: Point):
        new_path = []
        curr_point = dst
        while curr_point != src:
            new_path.append(curr_point)
            curr_point = self.prevs[curr_point]
        del new_path[0]
        self.paths.append(new_path)

    def readin(self, file):
        for line in file.readlines():
            self.add_row(line)
        self.do_padding()

    def run(self):
        self.change_tabs_to_spaces()
        self.find_starts()
        while self.starting_points:
            start = self.starting_points.pop()
            self.prevs.clear()
            visited = set([start])
            queue = deque([start])
            while queue:
                node = queue.popleft()
                current_char = self.field[node.row][node.col]
                if current_char == TARGET_CHAR:
                    self.add_path(start, node)
                    continue

                where_now = self.can_go_from(node)
                for point in where_now:
                    if point not in visited:
                        self.prevs[point] = node
                        visited.add(point)
                        queue.append(point)

    def __str__(self) -> str:
        self.run()
        lines = list(map(lambda l: list(l), self.field))
        for path in self.paths:
            for point in path:
                lines[point.row][point.col] = PATH_CHAR
        return '\n'.join(list(map(lambda line: ''.join(line), lines)))


parser = argparse.ArgumentParser()
parser.add_argument('file', help='The file you want to work on')
parser.add_argument('-s', '--starting',
                    help='The character you want to be the starting point of the search')
parser.add_argument('-t', '--target',
                    help='The character you want to be the target in search')
parser.add_argument('-p', '--path',
                    help='The character you want to draw paths with')
parser.add_argument('-n', '--neighbourhood',
                    help='The type of neighbourhood of character cells')


args = parser.parse_args()

file_path = args.file

try:
    the_file = open(file_path, 'r')
except IOError:
    print('Could not open file', file=sys.stderr)
    exit(-1)

if args.starting:
    validate_starting_char(args.starting)
if args.target:
    validate_target_char(args.target)
if args.path:
    validate_path_char(args.path)
if args.neighbourhood:
    validate_neighbourhood(args.neighbourhood)


world = World(EXTENDED_NEIGHBOURHOOD)
world.readin(the_file)
the_file.close()
print(world)

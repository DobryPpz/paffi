#!/usr/bin/env python3
'''
paffi
Copyright (C) 2024 Aleksander Modzelewski

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

This is a program where you input a text file consisting of lines of characters.
. -> this character means the starting points(default).
x -> this character means targets(default).
[:space:] -> whitespace means empty cells we can travel to.
Any other character means obstacle.
The program will read in such file and draw the shortest paths from starting
points to targets. The shortest paths will be drawn with @ character(default).
You can specify the following options:
-s:<c>  ->  the starting point character will be <c>
-t:<c>  ->  the target character will be <c>
-p:<c>  ->  the paths will be drawn with <c> character
-n:<c>  ->  the neighbourhood: 4 for Von Neumann(default), 8 for Moore
'''

import sys
from collections import deque, namedtuple

STARTING_CHAR = '.'
TARGET_CHAR = 'x'
PATH_CHAR = '@'
EXTENDED_NEIGHBOURHOOD = False


def parse_options(options_list):
    global STARTING_CHAR
    global TARGET_CHAR
    global PATH_CHAR
    global EXTENDED_NEIGHBOURHOOD
    option_set = set(['-s', '-t', '-p'])
    for option in options_list:
        if len(option) != 4:
            print(f'"{option}"  Wrong option format', file=sys.stderr)
            exit(-1)
        option_type, option_value = option[:2], option[3:]
        if option_type not in option_set:
            print(f'"{option_type}"  no such option available', file=sys.stderr)
            exit(-1)
        if option_type == '-s':
            STARTING_CHAR = option_value
        elif option_type == '-t':
            TARGET_CHAR = option_value
        elif option_type == '-p':
            PATH_CHAR = option_value


Point = namedtuple('point', ['row', 'col'])


def go_up(point: Point):
    return Point(point.row-1, point.col)


def go_up_right(point: Point):
    return Point(point.row-1, point.col+1)


def go_right(point: Point):
    return Point(point.row, point.col+1)


def go_down_right(point: Point):
    return Point(point.row+1, point.col+1)


def go_down(point: Point):
    return Point(point.row+1, point.col)


def go_down_left(point: Point):
    return Point(point.row+1, point.col-1)


def go_left(point: Point):
    return Point(point.row, point.col-1)


def go_up_left(point: Point):
    return Point(point.row-1, point.col-1)


class World:
    def __init__(self, extended_neighbourhood) -> None:
        self.field = []
        self.starting_points = []
        self.paths = []
        self.prevs = {}
        self.can_to = set([STARTING_CHAR, TARGET_CHAR, ' '])
        self.extended_neighbourhood = extended_neighbourhood
        self.possible_directions = [go_up, go_right,
                                    go_down, go_left] + ([
                                        go_up_right,
                                        go_up_left,
                                        go_down_right,
                                        go_down_left] if self.extended_neighbourhood else [])

    def add_row(self, row: str):
        row = row.strip('\n')
        if row != '':
            self.field.append(row)
        else:
            self.field.append(' ')

    def is_point_valid(self, point: Point):
        row = point.row
        col = point.col
        if row < 0 or row >= len(self.field):
            return False
        if col < 0 or col >= len(self.field[row]):
            return False
        if self.field[row][col] not in self.can_to:
            return False
        return True

    def do_padding(self):
        longest_line_len = 1
        for row in self.field:
            line_len = len(row)
            if line_len > longest_line_len:
                longest_line_len = line_len
        for i in range(len(self.field)):
            diff_len = longest_line_len - len(self.field[i])
            if diff_len > 0:
                self.field[i] += ' '*diff_len

    def change_tabs_to_spaces(self):
        num_rows = len(self.field)
        for r in range(num_rows):
            if '\t' in self.field[r]:
                self.field[r] = self.field[r].replace('\t', '    ')

    def can_go_from(self, point: Point):
        candidate_destinations = list(
            map(lambda dir: dir(point), self.possible_directions))
        possible_destinations = [
            d for d in candidate_destinations if self.is_point_valid(d)]
        return possible_destinations

    def find_starts(self):
        num_rows = len(self.field)
        for i in range(num_rows):
            row_len = len(self.field[i])
            for j in range(row_len):
                if self.field[i][j] == STARTING_CHAR:
                    self.starting_points.append(Point(i, j))

    def add_path(self, src: Point, dst: Point):
        new_path = []
        curr_point = dst
        while curr_point != src:
            new_path.append(curr_point)
            curr_point = self.prevs[curr_point]
        del new_path[0]
        self.paths.append(new_path)

    def readin(self, file):
        for line in file.readlines():
            self.add_row(line)
        self.do_padding()

    def run(self):
        self.change_tabs_to_spaces()
        self.find_starts()
        while self.starting_points:
            start = self.starting_points.pop()
            self.prevs.clear()
            visited = set([start])
            queue = deque([start])
            while queue:
                node = queue.popleft()
                current_char = self.field[node.row][node.col]
                if current_char == TARGET_CHAR:
                    self.add_path(start, node)

                where_now = self.can_go_from(node)
                for point in where_now:
                    if point not in visited:
                        self.prevs[point] = node
                        visited.add(point)
                        queue.append(point)

    def __str__(self) -> str:
        self.run()
        lines = list(map(lambda l: list(l), self.field))
        for path in self.paths:
            for point in path:
                lines[point.row][point.col] = PATH_CHAR
        return '\n'.join(list(map(lambda line: ''.join(line), lines)))


if len(sys.argv) < 2:
    print('Not enough arguments to paffi', file=sys.stderr)
    exit(-1)

file_path = sys.argv[-1]

try:
    the_file = open(file_path, 'r')
except OSError:
    print('Could not open the file', file=sys.stderr)
    exit(-1)

options_part = sys.argv[1:-1]
if options_part:
    parse_options(options_part)

world = World(EXTENDED_NEIGHBOURHOOD)
world.readin(the_file)
the_file.close()
print(world)
